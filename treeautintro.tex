Just as string automata describe sets of strings over some alphabet of
characters, tree automata describe sets of trees whose nodes are labeled
with elements of some set $\Sigma$.  We focus initially on {\em ranked} tree
automata.

\subsection{Notation for Trees}

\Note{Positions}
\Note{subterm-at-position}

$\Sigma_n \defeq \set{ \sigma \in \Sigma \middle\vert \mbox{ar}(\sigma) = n}$
and $\Sigma_+ \defeq \Sigma\setminus\Sigma_0$.

\subsection{Execution of Automata}

As with the string case, there will be configurations $\config$, and a
privileged subset $\config_F$.  However, transition functions are
quite different, and in fact split into two sub-classes of tree automata:%
%
\footnote{The transition functions presented here are for {\em
deterministic} automata.  See \autoref{xxx} for details of non-deterministic
automata.}
%
\begin{itemize}
%
  \item $\delta^{op} : \config \to \mathcal{T}(\Sigma \sqcup \config)$ defines a
  \defn{top-down} automaton, which can be thought of generating a tree
  root-first; the positions in the output which are configurations are
  recursively expanded into trees.
%
  \item $\delta : \mathcal{T}(\Sigma \sqcup \config) \to (1 + \config)$ defines a
  \defn{bottom-up} automaton, which can be thought of as consuming a tree
  leaves-first.  Note that we allow, in general, the automata to refuse to
  label a node (the $1$ return value), but certain classes of automata will
  not avail themselves of this option.
%
\end{itemize}

A \defn{run} of a tree automaton to be a tree in $\mathcal{T}\paren{\Sigma
\times (1 + \mathcal{T}(\Sigma \sqcup \config) \times \config)}$: an
augmented tree where each node is additionally, optionally, labeled by input
and output of $\delta$.  For each node $\sigma \times \mbox{inr}(t \times
c)$, $\delta t = c$ (or $\delta^{op} c = t$), and all positions of $t$ which
are in $\Sigma$ must agree with the first projection of the run itself, and
all positions of $t$ which are in $\config$ must be so-labeled by the run.
\Note{That's not very clear, but I think it's right.}

For a run $r$, we define $\tr(r|_p)$ to be the function which returns the
$\Sigma$ of the original tree at position $p$. (Symbolically, $\tr =
\pi_1$.)
Similarly, we define 
$\lab(r|_p)$ as the (partial) function which returns
the output configuration at position $p$. ($\lab = \pi_2 \mbox{inr}^{-1}
\pi_2$.)

\subsection{Nondeterminism}

\subsection{Plies}

An important subclass of tree automata are the \defn{single-ply} automata,
where $\delta$ is restricted to manipulation of trees of the form
$\mathcal{T}(\Sigma_+ \sqcup \config)$.

\subsection{Local Constraints}
\label{sec:treeaut:con:loc}

A natural novelty of tree automata is one of {\em constraints} between
positions in a (sub)tree.  One way of inducing such constraints is to
augment the transition function, inducing {\em local} tests in the tree; one
can think of this as including $\mathcal{T}(\Sigma)$ as a projection of
$\config$, though with restricted handling within the transition
function,\eg only comparison for (dis)equality.

We view a locally constrained automaton as a transition function which
performs a series of tests as part of its transition function {\em after
pattern matching}, meaning that it may be expressed as a (possibly infinite)
union of transitions of the form $\mathcal{T}(\Sigma \sqcup \config)
\stackrel{c}{\longrightarrow} \config$, where $c$ is a set of constraints.
The \defn{constraint path} is the concatenation of the paths between the
{\em labeled node whose labeling introduced the constraint} and the
constrained positions.

\subsubsection{Metaconstraints}

In general, tree automata with arbitrary constraints have very poor closure
properties (see \autoref{xxx}).  A variety of restrictions have been
developed throughout the literature and are summarized here.

\paragraph{Brothers} The transition function may only mutually constrain
positions which differ only in the last index.

\paragraph{Contained} All positions tested for equality must be within the
fragment of the tree being labeled (or generated); that is, constraint paths
may not involve a $\config$-labeled run node other than at their apex.

\paragraph{Opaque} If a position is constrained by a transition, no other
constraint path may cross this position. 

\paragraph{Reduction} There exists a partial order on $\config$ such that
$\forall_{t \in \mathcal{T}(\Sigma \sqcup \config), c \in \config}$, $t$ and
$c$ being related by transition implies that $\forall_{c' \in t} . c' \le
c$, strictly if the transition between $t$ and $c$ induces any constraints.

\subparagraph{Deep-Reduction} As above, but strictness is implied only when,
additionally, a position referenced by a constraint would be non-Contained.

\paragraph{Stated} All positions constrained must be labeled with some 
$\config$.

\subparagraph{$f$-Same-Stated} All positions mutually constrained must be
labeled (as above) and further the $f$-image of these configurations must be
identical.  (That is, the pattern of $\mathcal{T}(\Sigma \sqcup \config)$
matched by a transition must be sufficient to ensure that all constraint
paths end in equal-$f$-image nodes of the run.)  When $f$ is the identity
function or otherwise clear from context, we may simply say ``Same-Stated''.

\subsubsection{Interrelation of Metaconstraints}

Single-ply automata necessarily satisfy Stated, as every node in a run is
labeled.  Single-ply automata subject to Contained necessarily satisfy
Opaque; this is not true of multi-ply automata, as there may be crossing
constraints within a single multi-ply transition.

In general, Contained and Stated together imply Opaque.

In a deterministic automaton, satisfiable equality constraints referencing
labeled nodes are necessarily $f$-Same-Stated (for all $f$) as equal trees
produce equal runs.

\subsection{Transducers}

\subsection{Weighted Automata}

\subsection{Descriptive Taxonomy}

\subsection{Operational Taxonomy}
