String automata represent a {\em mechanical} description of languages over
$\Sigma$ (\ie subsets of the strings which may be formed from the
characters of a particular alphabet, $\Sigma$).  There are numerous
equivalent ways of stating this, possibly the most useful being that an
automaton can be thought of as an {\em indicator function} of type $\Sigma^*
\to 2$, signaling whether a given string is or is not part of its language.

\subsection{Execution of Automata}

At the core of each automaton will be a \defn{transition function},
$\delta$, which will take the current configuration of the machine (which we
shall denote in general with $c \in \config$) and a character of $\Sigma$ to
produce a new configuration (usually very closely related to the input
configuration, having been changed through a constrained interface).  Each
automaton will specify exactly one \defn{initial configuration}, $c_0 \in
\config$, and will designate some configurations as \defn{accepting
configurations}, $\config_F \subseteq \config$.

To test whether a particular string $\vec{s} = s_1 \ldots s_n \in \Sigma^*$
is in its language, one starts with the automaton in its initial
configuration, feeds its transition function each character of the string in
turn (\ie $s_1$, then $s_2$, and so on, up to $s_n$), and then looks to see
if the automaton is now in an accepting configuration.  More formally, we
can define a \defn{run} of an automaton as a string composed of alternating
elements of $\config$ and $\Sigma$.  If, after transitioning on $s_i$ the
machine is in configuration $c_i$, then $c_0 s_1 c_1 s_2 c_2 \ldots s_n c_n$
is the run of the machine on $\vec{s} \in \Sigma^*$.  A run is said to be
accepting if $c_n$ is an accepting configuration (\ie $c_n \in \config_F$).%
%
\footnote{It is equally sensible to feed strings through an automaton in
reverse and ask if, after receiving the first symbol of the (un-reversed)
string the machine is in an accepting configuration.}

\subsection{Nondeterministic Automata}

The above scenario described a \defn{deterministic} automaton, which always
make a particular move given a configuration and an input character.
Nondeterministic automata instead may take on {\em one of many}
configurations after receiving a character (as well as at initialization).
To model these, we define the transition function to result in a {\em set}
of configurations.%
%
\footnote{Many texts instead use a \defn{transition relation}.  While
equivalent, we find it useful to distinguish the inputs and outputs of the
transition process.}
%
Now a run of our nondeterministic machine looks like $C_0 s_1 C_1 \ldots s_n
C_n$ where each $C_i \subseteq \config$ and $c' \in C_{i+1}$ iff
$\exists_{c \in C_i} . c' \in \delta\paren{c,s_{i+1}}$.  We consider the
string $\vec{s}$ accepted by the automaton if {\em there exists} a run, as
defined earlier, where each $c_i \in C_i$, and $c_n \in \config_F$.

\subsection{Transducers}

A useful generalization of automata is from acceptors ($\Sigma^* \to 2$) to
transducers ($\Sigma^* \to \Sigma'^*$).  Here, $\delta$ not only outputs a
new configuration, it additionally outputs (sometimes optionally) a
character of the \defn{output alphabet} $\Sigma'$.  Nondeterministic
transducers' transition functions typically output a set of
configuration/character pairs ($(c, s') \in \config \times \Sigma'$).

\subsection{Weighted Automata}

Related to transducers are weighted automata, which may be thought of as
scoring or ranking input strings.  That is, rather than being indicator
functions $\Sigma^* \to 2$, they capture functions from $\Sigma^*$ to a
semi-ring, $R = \paren{0_R, 1_R, +_R, \times_R}$, such as $\mathbb{N}$ or
$\mathbb{R}$.  The typical definition of a weighted string automata has
$\delta$ producing an element of $R$ on each transition and adds two new
functions, which assign weights to the initial ($\config_0 \to R$) and
final ($\config_F \to R$) states.%
%
\footnote{For weighted {\em deterministic} automata, there is only one
initial configuration and so one typically elides the former function.}
%
The weight of a run is then the
$R$-product of its initial and final states' weights and the weights of all
transitions therein.  The weight of a string is the $R$-sum of all accepting
runs for that string.%
%
\footnote{Equivalently, we can think of a typical weighted automaton as a
non-deterministic {\em transducer to $R^*$} followed by per-run $R$-product
and cross-run $R$-sum reductions.}

\subsection{Descriptive Taxonomy}

We have said that an automaton's transition function $\delta$ has type
$\config \times \Sigma \to \config$, but that the input and output
configurations are often closely related.  In such a case, we may say that
$\delta$ is \defn{characterized} by a function of a different return
type.  What we mean by this is that the information bottleneck represented
by this alternate return type is sufficient to describe the change between
elements of $\config$ on a transition.  See the entry for
\hyperref[sec:zoo-str/pda]{Push-down Automata} for a simple example.

\subsection{Operational Taxonomy}

In an effort to neatly summarize many properties of string automata, entries
will typically be a brief prose description of the family followed by a
table containing common properties.  Uncommon properties or note-worthy
features will be left to prose.

Here, we use the common table to describe itself.  Given a string $s \in
\Sigma^*$, automata $A, A', \ldots$ and their languages $\alang{A},
\alang{A'}, \ldots$ ($\subseteq \Sigma^*$)...
\autinfo{
  member={$s \in \alang{A}$?},
  empty={$\alang{A} = \emptyset$?},
  univ={$\alang{A} = \Sigma^*$?},
  finite={$\abs{\alang{A}} < \infty$?},
  equiv={$\alang{A} = \alang{A'}$?},
  subset={$\alang{A} \subseteq \alang{A'}$?},
%
  kstar={Find $B$ s.t. $\alang{B} = \alang{A}^*$},
  kplus={Find $B$ s.t. $\alang{B} = \alang{A}^+$},
  compl={Find $B$ s.t. $\alang{B} = \Sigma^* \setminus \alang{A}$},
  relcompl={Find $B$ s.t. $\alang{B} = \alang{A} \setminus \alang{A'}$},
%
  intersect={Find $B$ s.t. $\alang{B} = \alang{A} \cap \alang{A'}$?},
  union={Find $B$ s.t.  $\alang{B} = \alang{A} \cup \alang{A'}$?},
%
  hom={Find $B$ for hom. $h$ s.t. $\alang{B} = h\paren{\alang{A}}$},
  invhom={Find $B$ for hom. $h$ s.t. $\alang{A} = h\paren{\alang{B}}$},
  efhom={Find $B$ for $\epsilon$-free hom. $h$ s.t. $\alang{B} =
         h\paren{\alang{A}}$},
%
  reginter={Find $B$ for \hyperref[sec:zoo-str/fsm]{regular language}
            $L$ s.t. $\alang{B} = \alang{A} \cap L$.},
%
  determinize={Find a deterministic $B$ with language equal to
             (nondet.) $A$.},
  minimize={Find a ``smallest'' $B$ with language equal to $A$.%
            %
            \footnote{``Smallest'' is not always straightforward to define.
            The goal, loosely, is to minimize the amount of information
            necessary to describe the automaton's configuration.}},
}

Of course, not every row in the table is independent of the others.  The
following implications (at least) hold in all cases:
\begin{itemize}
	\item Subset testing implies equivalence testing.
	\item Relative complement closure implies general complement closure.
	\item Intersection and general complement closures imply both subset testing
          and relative complement closure.
	\item Closure under arbitrary homomorphism implies closure under
          $\epsilon$-free homomorphisms.
\end{itemize}
